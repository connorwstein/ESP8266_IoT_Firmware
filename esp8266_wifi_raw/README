This is an experiment attempting to send and receive raw IEEE-802.11 packets from the ESP8266.

This is currently a dirty hack, and not quite perfect.

SENDING:
Currently, one can set the bytes 0, 1, and 4, 5, ..., etc of the frame to any arbitrary value.
But the bytes 2 and 3 (Duration ID in a normal IEEE-802.11 frame) are somehow overwritten
by the lower level driver functions, and appear to be always zero.

Also, the length of the packet as sent over the air does not always correspond
to the length of the buffer given as input. The lower layer functions appear to be allocating
enough memory for the whole IEEE-802.11 frame, and these additional bytes will be sent even if 
our actual buffer is shorter... But we do not yet understand what goes on below.

Another issue is that the method only works when the ESP is in SOFTAP_MODE.
In STATION_MODE, the eagle_lwip_getif function may crash, or the ieee80211_output_pbuf function
may return an error. We don't know why.


RECEIVING:
The method currently allows the device to enter in monitor mode, and sniff every packet
that can be found in the air, including control and management frames. There are no
limitations on the packet size as in the official sniffer APIs. You have access to
the complete frame.

Make sure you are listening in the correct channel and PHY mode.
Note that the ESP8266 does not seem to support the 5GHz wifi.

Update: It turns out the method only sniffs frames which are broadcast or directed to
	the device's own MAC address. It is not in promiscuous mode, so it can't receive
	all packets send over the air. It does receive the complete frames for packets
	that are actually processed by the driver. If we set the device to promiscuous
	mode (using wifi_enable_promiscuous(1)) the callback we set up does not get called anymore.
	It seems promicuous mode is dealt with differently, and the hardware may not be able
	to give the complete frames in this mode...

This can be thought of as a proof of concept, but there is still
a lot to work on. We don't know if we'll have the patience or ability to do so...


NOTES:

This program requires a modified libnet80211 and libpp library, which we called libnet80211_2.a and libpp2.a.
The modified net80211 library has its symbol table changed so that all references to ppTxPkt
are replaced with a dummy function called 'aaTxPkt' defined in user_main.c.
A simple way to do this is to go in the /opt/esp_open_sdk/sdk/lib/ folder, and do

sed s/ppTxPkt/aaTxPkt/g libnet80211.a > libnet80211_2.a

The libpp2.a library is a modified libpp.a library where the *undefined* references to ppEnqueueRxq
are replaced to references to aaEnqueueRxq. There will be one ppEnqueueRxq symbol corresponding to
the actual function definition, and this one should not be changed. Follow these steps:

cp libpp.a libpp2.a

Open libpp2.a with your favorite text editor, and replace the *first* and *second* occurence
of 'ppTxPkt' (without the quotes) with 'aaTxPkt' (without the quotes). There is a third occurence
in the file, do not replace it (keep it as 'ppTxPkt').

The Makefile must also be modified to link to net80211_2 and pp2 instead of net80211 and pp.
Use make -f Makefile2 to build, or run the ./compile_and_flash script (pass the port as a command line argument).
